{"ast":null,"code":"var _$;\n\nimport { pathToRegexp, match } from \"path-to-regexp\";\nimport { render, html, hydro, $, $$, setReuseElements } from \"hydro-js\";\nlet router;\nconst storageKey = \"router-scroll\";\nconst outletSelector = \"[data-outlet]\";\nconst reactivityRegex = /\\{\\{([^]*?)\\}\\}/;\nconst fetchCache = new WeakMap();\nlet base = ((_$ = $(\"base\")) === null || _$ === void 0 ? void 0 : _$.getAttribute(\"href\")) || \"\";\n\nif (base.endsWith(\"/\")) {\n  base = [...base].slice(0, -1).join(\"\");\n}\n\naddEventListener(\"popstate\", async e => {\n  //@ts-expect-error\n  router.doRouting(location.pathname + location.search, e);\n}); // Reload -> store scrollPosition\n\naddEventListener(\"beforeunload\", () => sessionStorage.setItem(storageKey, `${scrollX} ${scrollY}`));\nexport default class Router {\n  options;\n  routes;\n  oldRoute;\n\n  constructor(routes, options = {}) {\n    // Handle nested routes\n    const length = routes.length - 1;\n\n    for (let i = length; i >= 0; i--) {\n      const route = routes[i];\n\n      if (route.children) {\n        route.children.forEach((child, idx) => {\n          routes.splice(i + idx, 0, { ...child,\n            path: `${route.path}/${child.path}`,\n            isChildOf: route\n          });\n        });\n        Reflect.deleteProperty(route, \"children\");\n      }\n    }\n\n    const newRoutes = routes.map(route => {\n      return { ...route,\n        path: pathToRegexp(base + route.path),\n        originalPath: base + route.path\n      };\n    });\n    this.routes = newRoutes;\n    this.options = options;\n    router = this; // Prefetch resources\n\n    this.routes.forEach(route => {\n      var _navigator$connection;\n\n      //@ts-expect-error\n      if (route.templateUrl && !((_navigator$connection = navigator.connection) === null || _navigator$connection === void 0 ? void 0 : _navigator$connection.saveData)) {\n        const controller = new AbortController();\n        const cache = {\n          promise: null,\n          controller\n        };\n        fetchCache.set(route, cache);\n        setTimeout(() => {\n          requestIdleCallback(() => {\n            cache.promise = fetch(route.templateUrl, {\n              signal: controller.signal\n            });\n            cache.promise.then(res => res.text()).then(_html => {\n              cache.html = _html;\n            }).catch(async err => {\n              var _this$options$errorHa, _this$options;\n\n              await ((_this$options$errorHa = (_this$options = this.options).errorHandler) === null || _this$options$errorHa === void 0 ? void 0 : _this$options$errorHa.call(_this$options, err));\n            });\n          });\n        });\n      }\n    });\n    this.doRouting();\n  }\n\n  getMatchingRoute(path) {\n    if (path.startsWith(\".\")) {\n      path = path.replace(\".\", \"\");\n    }\n\n    return this.routes.find(route => route.path.exec(path));\n  }\n\n  async doRouting(to = location.pathname + location.search, e) {\n    dispatchEvent(new Event(\"beforeRouting\"));\n    const from = this.oldRoute ?? to;\n    const route = this.getMatchingRoute(to);\n\n    if (route) {\n      try {\n        var _route$beforeEnter, _route$afterEnter;\n\n        const {\n          params\n        } = match(route.originalPath, {\n          decode: decodeURIComponent\n        })(to);\n        const allParams = { ...Router.getParams(),\n          ...Object.fromEntries(Object.entries(params).map(pair => Number.isNaN(Number(pair[0])) && pair).filter(Boolean))\n        };\n        const props = {\n          from: from.replace(base, \"\"),\n          to: to.replace(base, \"\"),\n          ...(Object.keys(allParams).length ? {\n            params: allParams\n          } : {}),\n          ...(history.state && Object.keys(history.state).length ? {\n            state: history.state\n          } : {})\n        }; // Trigger leave\n\n        if (this.oldRoute) {\n          const oldRoute = this.routes.find(route => route.path.exec(this.oldRoute));\n\n          if (oldRoute) {\n            var _oldRoute$leave;\n\n            await ((_oldRoute$leave = oldRoute[\"leave\"\n            /* leave */\n            ]) === null || _oldRoute$leave === void 0 ? void 0 : _oldRoute$leave.call(oldRoute, props));\n            this.oldRoute = route.originalPath;\n          }\n        } // Trigger beforeEnter\n\n\n        await ((_route$beforeEnter = route[\"beforeEnter\"\n        /* beforeEnter */\n        ]) === null || _route$beforeEnter === void 0 ? void 0 : _route$beforeEnter.call(route, props)); // Handle template / element\n\n        if (!!route.isChildOf) {\n          setReuseElements(false);\n          const parent = route.isChildOf;\n\n          if (parent.templateUrl) {\n            await handleTemplate(parent, $(outletSelector));\n          } else if (parent.element) {\n            const copy = $(outletSelector).cloneNode();\n            copy.append(html`${parent.element}`);\n            render(copy, outletSelector, false);\n          }\n\n          setReuseElements(true);\n        }\n\n        if (route === null || route === void 0 ? void 0 : route.templateUrl) {\n          await handleTemplate(route, $(outletSelector).querySelector(outletSelector) ?? $(outletSelector));\n        } else if (route === null || route === void 0 ? void 0 : route.element) {\n          const where = $(outletSelector).querySelector(outletSelector) ?? $(outletSelector);\n          const copy = where.cloneNode();\n          copy.append(html`${route.element}`);\n          render(copy, where, false);\n        } else {\n          // Clear outlet\n          $(outletSelector).textContent = null;\n        } // Trigger afterEnter\n\n\n        await ((_route$afterEnter = route[\"afterEnter\"\n        /* afterEnter */\n        ]) === null || _route$afterEnter === void 0 ? void 0 : _route$afterEnter.call(route, props));\n      } catch (err) {\n        if (this.options.errorHandler) {\n          await this.options.errorHandler(err, e);\n        } else {\n          console.error(err, e);\n        }\n      } finally {\n        dispatchEvent(new Event(\"afterRouting\")); // Reload -> restore scroll position\n\n        if (!this.oldRoute && route.restoreScrollOnReload && sessionStorage.getItem(storageKey)) {\n          const [left, top] = sessionStorage.getItem(storageKey).split(\" \").map(Number);\n          sessionStorage.removeItem(storageKey);\n          scrollTo({\n            top,\n            left,\n            behavior: this.options.scrollBehavior || \"auto\"\n          });\n        }\n      }\n    }\n  }\n\n  go(path, state, params = \"\") {\n    this.oldRoute = location.pathname + location.search;\n    const newPath = base + path + params; // Only navigate when the path differs\n\n    if (newPath !== this.oldRoute) {\n      history.pushState({ ...state\n      }, \"\", newPath);\n      this.doRouting(newPath);\n    }\n  }\n\n  removeRoute(path) {\n    const idx = this.routes.findIndex(route => String(route.path) === String(pathToRegexp(path)));\n\n    if (idx > -1) {\n      this.routes.splice(idx, 1);\n    }\n  }\n\n  addRoute(route) {\n    this.routes.push({ ...route,\n      path: pathToRegexp(base + route.path),\n      originalPath: base + route.path\n    });\n  }\n\n  modifyRoute(path, newRoute) {\n    const idx = this.routes.findIndex(route => String(route.path) === String(pathToRegexp(path)));\n\n    if (idx > -1) {\n      this.routes[idx] = { ...newRoute,\n        path: pathToRegexp(base + newRoute.path),\n        originalPath: base + path\n      };\n    }\n  }\n\n  changeOptions(options) {\n    this.options = options;\n  }\n\n  static getParams(search = location.search) {\n    return Object.fromEntries(new URLSearchParams(search));\n  }\n\n}\n\nfunction registerAnchorEvent(anchor) {\n  var _anchor$getAttribute;\n\n  if ((_anchor$getAttribute = anchor.getAttribute(\"href\")) === null || _anchor$getAttribute === void 0 ? void 0 : _anchor$getAttribute.startsWith(\"http\")) return;\n  anchor.addEventListener(\"click\", e => {\n    e.preventDefault();\n    const hasData = anchor.getAttribute(\"data\");\n    const hydroProp = replaceBars(hasData);\n    const href = anchor.getAttribute(\"href\") || \"\";\n    router.go(href, hasData ? hydro[hydroProp] : void 0);\n  });\n}\n\nfunction registerFormEvent(form) {\n  form.addEventListener(\"submit\", e => {\n    if (!router.options.formHandler) return;\n    e.preventDefault();\n    const action = form.getAttribute(\"action\");\n    const method = form.getAttribute(\"method\");\n    fetch(action, {\n      method,\n      ...(![\"HEAD\", \"GET\"].includes(method.toUpperCase()) ? {\n        body: new FormData(form)\n      } : {})\n    }).then(res => router.options.formHandler(res, e)).catch(async err => {\n      if (router.options.errorHandler) {\n        await router.options.errorHandler(err, e);\n      } else {\n        console.error(err, e);\n      }\n    });\n  });\n}\n\nfunction replaceBars(hydroTerm) {\n  if (hydroTerm === null || !hydroTerm.includes(\"{{\")) return hydroTerm;\n  const [_, hydroPath] = hydroTerm.match(reactivityRegex) || [];\n  return hydroPath;\n} // Add EventListener for every added anchor and form Element\n\n\n$$(\"a\").forEach(registerAnchorEvent);\n$$(\"form\").forEach(registerFormEvent);\nnew MutationObserver(entries => {\n  for (const entry of entries) {\n    for (const node of entry.addedNodes) {\n      const nodes = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT, {\n        acceptNode(elem) {\n          return [\"form\", \"a\"].includes(elem.localName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;\n        }\n\n      });\n      let formOrA;\n\n      while (formOrA = nodes.nextNode()) {\n        if (formOrA.localName === \"a\") {\n          registerAnchorEvent(formOrA);\n        } else {\n          registerFormEvent(formOrA);\n        }\n      }\n    }\n  }\n}).observe(document.body, {\n  childList: true,\n  subtree: true\n});\n\nasync function handleTemplate(route, where) {\n  var _cacheObj;\n\n  let cacheObj = fetchCache.get(route);\n\n  if (!fetchCache.has(route) || ((_cacheObj = cacheObj) === null || _cacheObj === void 0 ? void 0 : _cacheObj.promise) === null) {\n    var _cacheObj$controller;\n\n    (_cacheObj$controller = cacheObj.controller) === null || _cacheObj$controller === void 0 ? void 0 : _cacheObj$controller.abort();\n    const data = await fetch(route.templateUrl);\n\n    if (!cacheObj) {\n      cacheObj = {\n        html: await data.text()\n      };\n      fetchCache.set(route, cacheObj);\n    } else {\n      cacheObj.html = await data.text();\n    }\n  }\n\n  Reflect.deleteProperty(cacheObj, \"controller\");\n  const copy = where.cloneNode();\n  copy.append(html`${(await cacheObj.html) || \"\"}`);\n  render(copy, where, false);\n}","map":{"version":3,"sources":["/Users/suzitpaudel/Desktop/prac/moviepractice/node_modules/router-dom/dist/router.js"],"names":["pathToRegexp","match","render","html","hydro","$","$$","setReuseElements","router","storageKey","outletSelector","reactivityRegex","fetchCache","WeakMap","base","getAttribute","endsWith","slice","join","addEventListener","e","doRouting","location","pathname","search","sessionStorage","setItem","scrollX","scrollY","Router","options","routes","oldRoute","constructor","length","i","route","children","forEach","child","idx","splice","path","isChildOf","Reflect","deleteProperty","newRoutes","map","originalPath","templateUrl","navigator","connection","saveData","controller","AbortController","cache","promise","set","setTimeout","requestIdleCallback","fetch","signal","then","res","text","_html","catch","err","errorHandler","getMatchingRoute","startsWith","replace","find","exec","to","dispatchEvent","Event","from","params","decode","decodeURIComponent","allParams","getParams","Object","fromEntries","entries","pair","Number","isNaN","filter","Boolean","props","keys","history","state","parent","handleTemplate","element","copy","cloneNode","append","querySelector","where","textContent","console","error","restoreScrollOnReload","getItem","left","top","split","removeItem","scrollTo","behavior","scrollBehavior","go","newPath","pushState","removeRoute","findIndex","String","addRoute","push","modifyRoute","newRoute","changeOptions","URLSearchParams","registerAnchorEvent","anchor","preventDefault","hasData","hydroProp","replaceBars","href","registerFormEvent","form","formHandler","action","method","includes","toUpperCase","body","FormData","hydroTerm","_","hydroPath","MutationObserver","entry","node","addedNodes","nodes","document","createNodeIterator","NodeFilter","SHOW_ELEMENT","acceptNode","elem","localName","FILTER_ACCEPT","FILTER_REJECT","formOrA","nextNode","observe","childList","subtree","cacheObj","get","has","abort","data"],"mappings":";;AAAA,SAASA,YAAT,EAAuBC,KAAvB,QAAoC,gBAApC;AACA,SAASC,MAAT,EAAiBC,IAAjB,EAAuBC,KAAvB,EAA8BC,CAA9B,EAAiCC,EAAjC,EAAqCC,gBAArC,QAA6D,UAA7D;AACA,IAAIC,MAAJ;AACA,MAAMC,UAAU,GAAG,eAAnB;AACA,MAAMC,cAAc,GAAG,eAAvB;AACA,MAAMC,eAAe,GAAG,iBAAxB;AACA,MAAMC,UAAU,GAAG,IAAIC,OAAJ,EAAnB;AACA,IAAIC,IAAI,GAAG,OAAAT,CAAC,CAAC,MAAD,CAAD,0CAAWU,YAAX,CAAwB,MAAxB,MAAmC,EAA9C;;AACA,IAAID,IAAI,CAACE,QAAL,CAAc,GAAd,CAAJ,EAAwB;AACpBF,EAAAA,IAAI,GAAG,CAAC,GAAGA,IAAJ,EAAUG,KAAV,CAAgB,CAAhB,EAAmB,CAAC,CAApB,EAAuBC,IAAvB,CAA4B,EAA5B,CAAP;AACH;;AACDC,gBAAgB,CAAC,UAAD,EAAa,MAAOC,CAAP,IAAa;AACtC;AACAZ,EAAAA,MAAM,CAACa,SAAP,CAAiBC,QAAQ,CAACC,QAAT,GAAoBD,QAAQ,CAACE,MAA9C,EAAsDJ,CAAtD;AACH,CAHe,CAAhB,C,CAIA;;AACAD,gBAAgB,CAAC,cAAD,EAAiB,MAAMM,cAAc,CAACC,OAAf,CAAuBjB,UAAvB,EAAoC,GAAEkB,OAAQ,IAAGC,OAAQ,EAAzD,CAAvB,CAAhB;AACA,eAAe,MAAMC,MAAN,CAAa;AACxBC,EAAAA,OAAO;AACPC,EAAAA,MAAM;AACNC,EAAAA,QAAQ;;AACRC,EAAAA,WAAW,CAACF,MAAD,EAASD,OAAO,GAAG,EAAnB,EAAuB;AAC9B;AACA,UAAMI,MAAM,GAAGH,MAAM,CAACG,MAAP,GAAgB,CAA/B;;AACA,SAAK,IAAIC,CAAC,GAAGD,MAAb,EAAqBC,CAAC,IAAI,CAA1B,EAA6BA,CAAC,EAA9B,EAAkC;AAC9B,YAAMC,KAAK,GAAGL,MAAM,CAACI,CAAD,CAApB;;AACA,UAAIC,KAAK,CAACC,QAAV,EAAoB;AAChBD,QAAAA,KAAK,CAACC,QAAN,CAAeC,OAAf,CAAuB,CAACC,KAAD,EAAQC,GAAR,KAAgB;AACnCT,UAAAA,MAAM,CAACU,MAAP,CAAcN,CAAC,GAAGK,GAAlB,EAAuB,CAAvB,EAA0B,EACtB,GAAGD,KADmB;AAEtBG,YAAAA,IAAI,EAAG,GAAEN,KAAK,CAACM,IAAK,IAAGH,KAAK,CAACG,IAAK,EAFZ;AAGtBC,YAAAA,SAAS,EAAEP;AAHW,WAA1B;AAKH,SAND;AAOAQ,QAAAA,OAAO,CAACC,cAAR,CAAuBT,KAAvB,EAA8B,UAA9B;AACH;AACJ;;AACD,UAAMU,SAAS,GAAGf,MAAM,CAACgB,GAAP,CAAYX,KAAD,IAAW;AACpC,aAAO,EACH,GAAGA,KADA;AAEHM,QAAAA,IAAI,EAAE1C,YAAY,CAACc,IAAI,GAAGsB,KAAK,CAACM,IAAd,CAFf;AAGHM,QAAAA,YAAY,EAAElC,IAAI,GAAGsB,KAAK,CAACM;AAHxB,OAAP;AAKH,KANiB,CAAlB;AAOA,SAAKX,MAAL,GAAce,SAAd;AACA,SAAKhB,OAAL,GAAeA,OAAf;AACAtB,IAAAA,MAAM,GAAG,IAAT,CAzB8B,CA0B9B;;AACA,SAAKuB,MAAL,CAAYO,OAAZ,CAAqBF,KAAD,IAAW;AAAA;;AAC3B;AACA,UAAIA,KAAK,CAACa,WAAN,IAAqB,2BAACC,SAAS,CAACC,UAAX,0DAAC,sBAAsBC,QAAvB,CAAzB,EAA0D;AACtD,cAAMC,UAAU,GAAG,IAAIC,eAAJ,EAAnB;AACA,cAAMC,KAAK,GAAG;AAAEC,UAAAA,OAAO,EAAE,IAAX;AAAiBH,UAAAA;AAAjB,SAAd;AACAzC,QAAAA,UAAU,CAAC6C,GAAX,CAAerB,KAAf,EAAsBmB,KAAtB;AACAG,QAAAA,UAAU,CAAC,MAAM;AACbC,UAAAA,mBAAmB,CAAC,MAAM;AACtBJ,YAAAA,KAAK,CAACC,OAAN,GAAgBI,KAAK,CAACxB,KAAK,CAACa,WAAP,EAAoB;AACrCY,cAAAA,MAAM,EAAER,UAAU,CAACQ;AADkB,aAApB,CAArB;AAGAN,YAAAA,KAAK,CAACC,OAAN,CACKM,IADL,CACWC,GAAD,IAASA,GAAG,CAACC,IAAJ,EADnB,EAEKF,IAFL,CAEWG,KAAD,IAAW;AACjBV,cAAAA,KAAK,CAACpD,IAAN,GAAa8D,KAAb;AACH,aAJD,EAKKC,KALL,CAKW,MAAOC,GAAP,IAAe;AAAA;;AACtB,8CAAM,sBAAKrC,OAAL,EAAasC,YAAnB,0DAAM,0CAA4BD,GAA5B,CAAN;AACH,aAPD;AAQH,WAZkB,CAAnB;AAaH,SAdS,CAAV;AAeH;AACJ,KAtBD;AAuBA,SAAK9C,SAAL;AACH;;AACDgD,EAAAA,gBAAgB,CAAC3B,IAAD,EAAO;AACnB,QAAIA,IAAI,CAAC4B,UAAL,CAAgB,GAAhB,CAAJ,EAA0B;AACtB5B,MAAAA,IAAI,GAAGA,IAAI,CAAC6B,OAAL,CAAa,GAAb,EAAkB,EAAlB,CAAP;AACH;;AACD,WAAO,KAAKxC,MAAL,CAAYyC,IAAZ,CAAkBpC,KAAD,IAAWA,KAAK,CAACM,IAAN,CAAW+B,IAAX,CAAgB/B,IAAhB,CAA5B,CAAP;AACH;;AACc,QAATrB,SAAS,CAACqD,EAAE,GAAGpD,QAAQ,CAACC,QAAT,GAAoBD,QAAQ,CAACE,MAAnC,EAA2CJ,CAA3C,EAA8C;AACzDuD,IAAAA,aAAa,CAAC,IAAIC,KAAJ,CAAU,eAAV,CAAD,CAAb;AACA,UAAMC,IAAI,GAAG,KAAK7C,QAAL,IAAiB0C,EAA9B;AACA,UAAMtC,KAAK,GAAG,KAAKiC,gBAAL,CAAsBK,EAAtB,CAAd;;AACA,QAAItC,KAAJ,EAAW;AACP,UAAI;AAAA;;AACA,cAAM;AAAE0C,UAAAA;AAAF,YAAa7E,KAAK,CAACmC,KAAK,CAACY,YAAP,EAAqB;AACzC+B,UAAAA,MAAM,EAAEC;AADiC,SAArB,CAAL,CAEhBN,EAFgB,CAAnB;AAGA,cAAMO,SAAS,GAAG,EACd,GAAGpD,MAAM,CAACqD,SAAP,EADW;AAEd,aAAGC,MAAM,CAACC,WAAP,CAAmBD,MAAM,CAACE,OAAP,CAAeP,MAAf,EACjB/B,GADiB,CACZuC,IAAD,IAAUC,MAAM,CAACC,KAAP,CAAaD,MAAM,CAACD,IAAI,CAAC,CAAD,CAAL,CAAnB,KAAiCA,IAD9B,EAEjBG,MAFiB,CAEVC,OAFU,CAAnB;AAFW,SAAlB;AAMA,cAAMC,KAAK,GAAG;AACVd,UAAAA,IAAI,EAAEA,IAAI,CAACN,OAAL,CAAazD,IAAb,EAAmB,EAAnB,CADI;AAEV4D,UAAAA,EAAE,EAAEA,EAAE,CAACH,OAAH,CAAWzD,IAAX,EAAiB,EAAjB,CAFM;AAGV,cAAIqE,MAAM,CAACS,IAAP,CAAYX,SAAZ,EAAuB/C,MAAvB,GAAgC;AAAE4C,YAAAA,MAAM,EAAEG;AAAV,WAAhC,GAAwD,EAA5D,CAHU;AAIV,cAAIY,OAAO,CAACC,KAAR,IAAiBX,MAAM,CAACS,IAAP,CAAYC,OAAO,CAACC,KAApB,EAA2B5D,MAA5C,GACE;AAAE4D,YAAAA,KAAK,EAAED,OAAO,CAACC;AAAjB,WADF,GAEE,EAFN;AAJU,SAAd,CAVA,CAkBA;;AACA,YAAI,KAAK9D,QAAT,EAAmB;AACf,gBAAMA,QAAQ,GAAG,KAAKD,MAAL,CAAYyC,IAAZ,CAAkBpC,KAAD,IAAWA,KAAK,CAACM,IAAN,CAAW+B,IAAX,CAAgB,KAAKzC,QAArB,CAA5B,CAAjB;;AACA,cAAIA,QAAJ,EAAc;AAAA;;AACV,sCAAMA,QAAQ,CAAC;AAAQ;AAAT,aAAd,oDAAM,qBAAAA,QAAQ,EAAwB2D,KAAxB,CAAd;AACA,iBAAK3D,QAAL,GAAgBI,KAAK,CAACY,YAAtB;AACH;AACJ,SAzBD,CA0BA;;;AACA,qCAAMZ,KAAK,CAAC;AAAc;AAAf,SAAX,uDAAM,wBAAAA,KAAK,EAAoCuD,KAApC,CAAX,EA3BA,CA4BA;;AACA,YAAI,CAAC,CAACvD,KAAK,CAACO,SAAZ,EAAuB;AACnBpC,UAAAA,gBAAgB,CAAC,KAAD,CAAhB;AACA,gBAAMwF,MAAM,GAAG3D,KAAK,CAACO,SAArB;;AACA,cAAIoD,MAAM,CAAC9C,WAAX,EAAwB;AACpB,kBAAM+C,cAAc,CAACD,MAAD,EAAS1F,CAAC,CAACK,cAAD,CAAV,CAApB;AACH,WAFD,MAGK,IAAIqF,MAAM,CAACE,OAAX,EAAoB;AACrB,kBAAMC,IAAI,GAAG7F,CAAC,CAACK,cAAD,CAAD,CAAkByF,SAAlB,EAAb;AACAD,YAAAA,IAAI,CAACE,MAAL,CAAYjG,IAAM,GAAE4F,MAAM,CAACE,OAAQ,EAAnC;AACA/F,YAAAA,MAAM,CAACgG,IAAD,EAAOxF,cAAP,EAAuB,KAAvB,CAAN;AACH;;AACDH,UAAAA,gBAAgB,CAAC,IAAD,CAAhB;AACH;;AACD,YAAI6B,KAAJ,aAAIA,KAAJ,uBAAIA,KAAK,CAAEa,WAAX,EAAwB;AACpB,gBAAM+C,cAAc,CAAC5D,KAAD,EAAQ/B,CAAC,CAACK,cAAD,CAAD,CAAkB2F,aAAlB,CAAgC3F,cAAhC,KACxBL,CAAC,CAACK,cAAD,CADe,CAApB;AAEH,SAHD,MAIK,IAAI0B,KAAJ,aAAIA,KAAJ,uBAAIA,KAAK,CAAE6D,OAAX,EAAoB;AACrB,gBAAMK,KAAK,GAAGjG,CAAC,CAACK,cAAD,CAAD,CAAkB2F,aAAlB,CAAgC3F,cAAhC,KACVL,CAAC,CAACK,cAAD,CADL;AAEA,gBAAMwF,IAAI,GAAGI,KAAK,CAACH,SAAN,EAAb;AACAD,UAAAA,IAAI,CAACE,MAAL,CAAYjG,IAAM,GAAEiC,KAAK,CAAC6D,OAAQ,EAAlC;AACA/F,UAAAA,MAAM,CAACgG,IAAD,EAAOI,KAAP,EAAc,KAAd,CAAN;AACH,SANI,MAOA;AACD;AACAjG,UAAAA,CAAC,CAACK,cAAD,CAAD,CAAkB6F,WAAlB,GAAgC,IAAhC;AACH,SAxDD,CAyDA;;;AACA,oCAAMnE,KAAK,CAAC;AAAa;AAAd,SAAX,sDAAM,uBAAAA,KAAK,EAAkCuD,KAAlC,CAAX;AACH,OA3DD,CA4DA,OAAOxB,GAAP,EAAY;AACR,YAAI,KAAKrC,OAAL,CAAasC,YAAjB,EAA+B;AAC3B,gBAAM,KAAKtC,OAAL,CAAasC,YAAb,CAA0BD,GAA1B,EAA+B/C,CAA/B,CAAN;AACH,SAFD,MAGK;AACDoF,UAAAA,OAAO,CAACC,KAAR,CAActC,GAAd,EAAmB/C,CAAnB;AACH;AACJ,OAnED,SAoEQ;AACJuD,QAAAA,aAAa,CAAC,IAAIC,KAAJ,CAAU,cAAV,CAAD,CAAb,CADI,CAEJ;;AACA,YAAI,CAAC,KAAK5C,QAAN,IACAI,KAAK,CAACsE,qBADN,IAEAjF,cAAc,CAACkF,OAAf,CAAuBlG,UAAvB,CAFJ,EAEwC;AACpC,gBAAM,CAACmG,IAAD,EAAOC,GAAP,IAAcpF,cAAc,CAC7BkF,OADe,CACPlG,UADO,EAEfqG,KAFe,CAET,GAFS,EAGf/D,GAHe,CAGXwC,MAHW,CAApB;AAIA9D,UAAAA,cAAc,CAACsF,UAAf,CAA0BtG,UAA1B;AACAuG,UAAAA,QAAQ,CAAC;AACLH,YAAAA,GADK;AAELD,YAAAA,IAFK;AAGLK,YAAAA,QAAQ,EAAE,KAAKnF,OAAL,CAAaoF,cAAb,IAA+B;AAHpC,WAAD,CAAR;AAKH;AACJ;AACJ;AACJ;;AACDC,EAAAA,EAAE,CAACzE,IAAD,EAAOoD,KAAP,EAAchB,MAAM,GAAG,EAAvB,EAA2B;AACzB,SAAK9C,QAAL,GAAgBV,QAAQ,CAACC,QAAT,GAAoBD,QAAQ,CAACE,MAA7C;AACA,UAAM4F,OAAO,GAAGtG,IAAI,GAAG4B,IAAP,GAAcoC,MAA9B,CAFyB,CAGzB;;AACA,QAAIsC,OAAO,KAAK,KAAKpF,QAArB,EAA+B;AAC3B6D,MAAAA,OAAO,CAACwB,SAAR,CAAkB,EAAE,GAAGvB;AAAL,OAAlB,EAAgC,EAAhC,EAAoCsB,OAApC;AACA,WAAK/F,SAAL,CAAe+F,OAAf;AACH;AACJ;;AACDE,EAAAA,WAAW,CAAC5E,IAAD,EAAO;AACd,UAAMF,GAAG,GAAG,KAAKT,MAAL,CAAYwF,SAAZ,CAAuBnF,KAAD,IAAWoF,MAAM,CAACpF,KAAK,CAACM,IAAP,CAAN,KAAuB8E,MAAM,CAACxH,YAAY,CAAC0C,IAAD,CAAb,CAA9D,CAAZ;;AACA,QAAIF,GAAG,GAAG,CAAC,CAAX,EAAc;AACV,WAAKT,MAAL,CAAYU,MAAZ,CAAmBD,GAAnB,EAAwB,CAAxB;AACH;AACJ;;AACDiF,EAAAA,QAAQ,CAACrF,KAAD,EAAQ;AACZ,SAAKL,MAAL,CAAY2F,IAAZ,CAAiB,EACb,GAAGtF,KADU;AAEbM,MAAAA,IAAI,EAAE1C,YAAY,CAACc,IAAI,GAAGsB,KAAK,CAACM,IAAd,CAFL;AAGbM,MAAAA,YAAY,EAAElC,IAAI,GAAGsB,KAAK,CAACM;AAHd,KAAjB;AAKH;;AACDiF,EAAAA,WAAW,CAACjF,IAAD,EAAOkF,QAAP,EAAiB;AACxB,UAAMpF,GAAG,GAAG,KAAKT,MAAL,CAAYwF,SAAZ,CAAuBnF,KAAD,IAAWoF,MAAM,CAACpF,KAAK,CAACM,IAAP,CAAN,KAAuB8E,MAAM,CAACxH,YAAY,CAAC0C,IAAD,CAAb,CAA9D,CAAZ;;AACA,QAAIF,GAAG,GAAG,CAAC,CAAX,EAAc;AACV,WAAKT,MAAL,CAAYS,GAAZ,IAAmB,EACf,GAAGoF,QADY;AAEflF,QAAAA,IAAI,EAAE1C,YAAY,CAACc,IAAI,GAAG8G,QAAQ,CAAClF,IAAjB,CAFH;AAGfM,QAAAA,YAAY,EAAElC,IAAI,GAAG4B;AAHN,OAAnB;AAKH;AACJ;;AACDmF,EAAAA,aAAa,CAAC/F,OAAD,EAAU;AACnB,SAAKA,OAAL,GAAeA,OAAf;AACH;;AACe,SAAToD,SAAS,CAAC1D,MAAM,GAAGF,QAAQ,CAACE,MAAnB,EAA2B;AACvC,WAAO2D,MAAM,CAACC,WAAP,CAAmB,IAAI0C,eAAJ,CAAoBtG,MAApB,CAAnB,CAAP;AACH;;AAhMuB;;AAkM5B,SAASuG,mBAAT,CAA6BC,MAA7B,EAAqC;AAAA;;AACjC,8BAAIA,MAAM,CAACjH,YAAP,CAAoB,MAApB,CAAJ,yDAAI,qBAA6BuD,UAA7B,CAAwC,MAAxC,CAAJ,EACI;AACJ0D,EAAAA,MAAM,CAAC7G,gBAAP,CAAwB,OAAxB,EAAkCC,CAAD,IAAO;AACpCA,IAAAA,CAAC,CAAC6G,cAAF;AACA,UAAMC,OAAO,GAAGF,MAAM,CAACjH,YAAP,CAAoB,MAApB,CAAhB;AACA,UAAMoH,SAAS,GAAGC,WAAW,CAACF,OAAD,CAA7B;AACA,UAAMG,IAAI,GAAGL,MAAM,CAACjH,YAAP,CAAoB,MAApB,KAA+B,EAA5C;AACAP,IAAAA,MAAM,CAAC2G,EAAP,CAAUkB,IAAV,EAAgBH,OAAO,GAAG9H,KAAK,CAAC+H,SAAD,CAAR,GAAsB,KAAK,CAAlD;AACH,GAND;AAOH;;AACD,SAASG,iBAAT,CAA2BC,IAA3B,EAAiC;AAC7BA,EAAAA,IAAI,CAACpH,gBAAL,CAAsB,QAAtB,EAAiCC,CAAD,IAAO;AACnC,QAAI,CAACZ,MAAM,CAACsB,OAAP,CAAe0G,WAApB,EACI;AACJpH,IAAAA,CAAC,CAAC6G,cAAF;AACA,UAAMQ,MAAM,GAAGF,IAAI,CAACxH,YAAL,CAAkB,QAAlB,CAAf;AACA,UAAM2H,MAAM,GAAGH,IAAI,CAACxH,YAAL,CAAkB,QAAlB,CAAf;AACA6C,IAAAA,KAAK,CAAC6E,MAAD,EAAS;AACVC,MAAAA,MADU;AAEV,UAAI,CAAC,CAAC,MAAD,EAAS,KAAT,EAAgBC,QAAhB,CAAyBD,MAAM,CAACE,WAAP,EAAzB,CAAD,GACE;AAAEC,QAAAA,IAAI,EAAE,IAAIC,QAAJ,CAAaP,IAAb;AAAR,OADF,GAEE,EAFN;AAFU,KAAT,CAAL,CAMKzE,IANL,CAMWC,GAAD,IAASvD,MAAM,CAACsB,OAAP,CAAe0G,WAAf,CAA2BzE,GAA3B,EAAgC3C,CAAhC,CANnB,EAOK8C,KAPL,CAOW,MAAOC,GAAP,IAAe;AACtB,UAAI3D,MAAM,CAACsB,OAAP,CAAesC,YAAnB,EAAiC;AAC7B,cAAM5D,MAAM,CAACsB,OAAP,CAAesC,YAAf,CAA4BD,GAA5B,EAAiC/C,CAAjC,CAAN;AACH,OAFD,MAGK;AACDoF,QAAAA,OAAO,CAACC,KAAR,CAActC,GAAd,EAAmB/C,CAAnB;AACH;AACJ,KAdD;AAeH,GArBD;AAsBH;;AACD,SAASgH,WAAT,CAAqBW,SAArB,EAAgC;AAC5B,MAAIA,SAAS,KAAK,IAAd,IAAsB,CAACA,SAAS,CAACJ,QAAV,CAAmB,IAAnB,CAA3B,EACI,OAAOI,SAAP;AACJ,QAAM,CAACC,CAAD,EAAIC,SAAJ,IAAiBF,SAAS,CAAC9I,KAAV,CAAgBU,eAAhB,KAAoC,EAA3D;AACA,SAAOsI,SAAP;AACH,C,CACD;;;AACA3I,EAAE,CAAC,GAAD,CAAF,CAAQgC,OAAR,CAAgByF,mBAAhB;AACAzH,EAAE,CAAC,MAAD,CAAF,CAAWgC,OAAX,CAAmBgG,iBAAnB;AACA,IAAIY,gBAAJ,CAAsB7D,OAAD,IAAa;AAC9B,OAAK,MAAM8D,KAAX,IAAoB9D,OAApB,EAA6B;AACzB,SAAK,MAAM+D,IAAX,IAAmBD,KAAK,CAACE,UAAzB,EAAqC;AACjC,YAAMC,KAAK,GAAGC,QAAQ,CAACC,kBAAT,CAA4BJ,IAA5B,EAAkCK,UAAU,CAACC,YAA7C,EAA2D;AACrEC,QAAAA,UAAU,CAACC,IAAD,EAAO;AACb,iBAAO,CAAC,MAAD,EAAS,GAAT,EAAcjB,QAAd,CAAuBiB,IAAI,CAACC,SAA5B,IACDJ,UAAU,CAACK,aADV,GAEDL,UAAU,CAACM,aAFjB;AAGH;;AALoE,OAA3D,CAAd;AAOA,UAAIC,OAAJ;;AACA,aAAQA,OAAO,GAAGV,KAAK,CAACW,QAAN,EAAlB,EAAqC;AACjC,YAAID,OAAO,CAACH,SAAR,KAAsB,GAA1B,EAA+B;AAC3B9B,UAAAA,mBAAmB,CAACiC,OAAD,CAAnB;AACH,SAFD,MAGK;AACD1B,UAAAA,iBAAiB,CAAC0B,OAAD,CAAjB;AACH;AACJ;AACJ;AACJ;AACJ,CArBD,EAqBGE,OArBH,CAqBWX,QAAQ,CAACV,IArBpB,EAqB0B;AAAEsB,EAAAA,SAAS,EAAE,IAAb;AAAmBC,EAAAA,OAAO,EAAE;AAA5B,CArB1B;;AAsBA,eAAepE,cAAf,CAA8B5D,KAA9B,EAAqCkE,KAArC,EAA4C;AAAA;;AACxC,MAAI+D,QAAQ,GAAGzJ,UAAU,CAAC0J,GAAX,CAAelI,KAAf,CAAf;;AACA,MAAI,CAACxB,UAAU,CAAC2J,GAAX,CAAenI,KAAf,CAAD,IAA0B,cAAAiI,QAAQ,UAAR,8CAAU7G,OAAV,MAAsB,IAApD,EAA0D;AAAA;;AACtD,4BAAA6G,QAAQ,CAAChH,UAAT,8EAAqBmH,KAArB;AACA,UAAMC,IAAI,GAAG,MAAM7G,KAAK,CAACxB,KAAK,CAACa,WAAP,CAAxB;;AACA,QAAI,CAACoH,QAAL,EAAe;AACXA,MAAAA,QAAQ,GAAG;AACPlK,QAAAA,IAAI,EAAE,MAAMsK,IAAI,CAACzG,IAAL;AADL,OAAX;AAGApD,MAAAA,UAAU,CAAC6C,GAAX,CAAerB,KAAf,EAAsBiI,QAAtB;AACH,KALD,MAMK;AACDA,MAAAA,QAAQ,CAAClK,IAAT,GAAgB,MAAMsK,IAAI,CAACzG,IAAL,EAAtB;AACH;AACJ;;AACDpB,EAAAA,OAAO,CAACC,cAAR,CAAuBwH,QAAvB,EAAiC,YAAjC;AACA,QAAMnE,IAAI,GAAGI,KAAK,CAACH,SAAN,EAAb;AACAD,EAAAA,IAAI,CAACE,MAAL,CAAYjG,IAAM,GAAE,CAAC,MAAMkK,QAAQ,CAAClK,IAAhB,KAAyB,EAAG,EAAhD;AACAD,EAAAA,MAAM,CAACgG,IAAD,EAAOI,KAAP,EAAc,KAAd,CAAN;AACH","sourcesContent":["import { pathToRegexp, match } from \"path-to-regexp\";\r\nimport { render, html, hydro, $, $$, setReuseElements } from \"hydro-js\";\r\nlet router;\r\nconst storageKey = \"router-scroll\";\r\nconst outletSelector = \"[data-outlet]\";\r\nconst reactivityRegex = /\\{\\{([^]*?)\\}\\}/;\r\nconst fetchCache = new WeakMap();\r\nlet base = $(\"base\")?.getAttribute(\"href\") || \"\";\r\nif (base.endsWith(\"/\")) {\r\n    base = [...base].slice(0, -1).join(\"\");\r\n}\r\naddEventListener(\"popstate\", async (e) => {\r\n    //@ts-expect-error\r\n    router.doRouting(location.pathname + location.search, e);\r\n});\r\n// Reload -> store scrollPosition\r\naddEventListener(\"beforeunload\", () => sessionStorage.setItem(storageKey, `${scrollX} ${scrollY}`));\r\nexport default class Router {\r\n    options;\r\n    routes;\r\n    oldRoute;\r\n    constructor(routes, options = {}) {\r\n        // Handle nested routes\r\n        const length = routes.length - 1;\r\n        for (let i = length; i >= 0; i--) {\r\n            const route = routes[i];\r\n            if (route.children) {\r\n                route.children.forEach((child, idx) => {\r\n                    routes.splice(i + idx, 0, {\r\n                        ...child,\r\n                        path: `${route.path}/${child.path}`,\r\n                        isChildOf: route,\r\n                    });\r\n                });\r\n                Reflect.deleteProperty(route, \"children\");\r\n            }\r\n        }\r\n        const newRoutes = routes.map((route) => {\r\n            return {\r\n                ...route,\r\n                path: pathToRegexp(base + route.path),\r\n                originalPath: base + route.path,\r\n            };\r\n        });\r\n        this.routes = newRoutes;\r\n        this.options = options;\r\n        router = this;\r\n        // Prefetch resources\r\n        this.routes.forEach((route) => {\r\n            //@ts-expect-error\r\n            if (route.templateUrl && !navigator.connection?.saveData) {\r\n                const controller = new AbortController();\r\n                const cache = { promise: null, controller };\r\n                fetchCache.set(route, cache);\r\n                setTimeout(() => {\r\n                    requestIdleCallback(() => {\r\n                        cache.promise = fetch(route.templateUrl, {\r\n                            signal: controller.signal,\r\n                        });\r\n                        cache.promise\r\n                            .then((res) => res.text())\r\n                            .then((_html) => {\r\n                            cache.html = _html;\r\n                        })\r\n                            .catch(async (err) => {\r\n                            await this.options.errorHandler?.(err);\r\n                        });\r\n                    });\r\n                });\r\n            }\r\n        });\r\n        this.doRouting();\r\n    }\r\n    getMatchingRoute(path) {\r\n        if (path.startsWith(\".\")) {\r\n            path = path.replace(\".\", \"\");\r\n        }\r\n        return this.routes.find((route) => route.path.exec(path));\r\n    }\r\n    async doRouting(to = location.pathname + location.search, e) {\r\n        dispatchEvent(new Event(\"beforeRouting\"));\r\n        const from = this.oldRoute ?? to;\r\n        const route = this.getMatchingRoute(to);\r\n        if (route) {\r\n            try {\r\n                const { params } = match(route.originalPath, {\r\n                    decode: decodeURIComponent,\r\n                })(to);\r\n                const allParams = {\r\n                    ...Router.getParams(),\r\n                    ...Object.fromEntries(Object.entries(params)\r\n                        .map((pair) => Number.isNaN(Number(pair[0])) && pair)\r\n                        .filter(Boolean)),\r\n                };\r\n                const props = {\r\n                    from: from.replace(base, \"\"),\r\n                    to: to.replace(base, \"\"),\r\n                    ...(Object.keys(allParams).length ? { params: allParams } : {}),\r\n                    ...(history.state && Object.keys(history.state).length\r\n                        ? { state: history.state }\r\n                        : {}),\r\n                };\r\n                // Trigger leave\r\n                if (this.oldRoute) {\r\n                    const oldRoute = this.routes.find((route) => route.path.exec(this.oldRoute));\r\n                    if (oldRoute) {\r\n                        await oldRoute[\"leave\" /* leave */]?.(props);\r\n                        this.oldRoute = route.originalPath;\r\n                    }\r\n                }\r\n                // Trigger beforeEnter\r\n                await route[\"beforeEnter\" /* beforeEnter */]?.(props);\r\n                // Handle template / element\r\n                if (!!route.isChildOf) {\r\n                    setReuseElements(false);\r\n                    const parent = route.isChildOf;\r\n                    if (parent.templateUrl) {\r\n                        await handleTemplate(parent, $(outletSelector));\r\n                    }\r\n                    else if (parent.element) {\r\n                        const copy = $(outletSelector).cloneNode();\r\n                        copy.append(html `${parent.element}`);\r\n                        render(copy, outletSelector, false);\r\n                    }\r\n                    setReuseElements(true);\r\n                }\r\n                if (route?.templateUrl) {\r\n                    await handleTemplate(route, $(outletSelector).querySelector(outletSelector) ??\r\n                        $(outletSelector));\r\n                }\r\n                else if (route?.element) {\r\n                    const where = $(outletSelector).querySelector(outletSelector) ??\r\n                        $(outletSelector);\r\n                    const copy = where.cloneNode();\r\n                    copy.append(html `${route.element}`);\r\n                    render(copy, where, false);\r\n                }\r\n                else {\r\n                    // Clear outlet\r\n                    $(outletSelector).textContent = null;\r\n                }\r\n                // Trigger afterEnter\r\n                await route[\"afterEnter\" /* afterEnter */]?.(props);\r\n            }\r\n            catch (err) {\r\n                if (this.options.errorHandler) {\r\n                    await this.options.errorHandler(err, e);\r\n                }\r\n                else {\r\n                    console.error(err, e);\r\n                }\r\n            }\r\n            finally {\r\n                dispatchEvent(new Event(\"afterRouting\"));\r\n                // Reload -> restore scroll position\r\n                if (!this.oldRoute &&\r\n                    route.restoreScrollOnReload &&\r\n                    sessionStorage.getItem(storageKey)) {\r\n                    const [left, top] = sessionStorage\r\n                        .getItem(storageKey)\r\n                        .split(\" \")\r\n                        .map(Number);\r\n                    sessionStorage.removeItem(storageKey);\r\n                    scrollTo({\r\n                        top,\r\n                        left,\r\n                        behavior: this.options.scrollBehavior || \"auto\",\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    go(path, state, params = \"\") {\r\n        this.oldRoute = location.pathname + location.search;\r\n        const newPath = base + path + params;\r\n        // Only navigate when the path differs\r\n        if (newPath !== this.oldRoute) {\r\n            history.pushState({ ...state }, \"\", newPath);\r\n            this.doRouting(newPath);\r\n        }\r\n    }\r\n    removeRoute(path) {\r\n        const idx = this.routes.findIndex((route) => String(route.path) === String(pathToRegexp(path)));\r\n        if (idx > -1) {\r\n            this.routes.splice(idx, 1);\r\n        }\r\n    }\r\n    addRoute(route) {\r\n        this.routes.push({\r\n            ...route,\r\n            path: pathToRegexp(base + route.path),\r\n            originalPath: base + route.path,\r\n        });\r\n    }\r\n    modifyRoute(path, newRoute) {\r\n        const idx = this.routes.findIndex((route) => String(route.path) === String(pathToRegexp(path)));\r\n        if (idx > -1) {\r\n            this.routes[idx] = {\r\n                ...newRoute,\r\n                path: pathToRegexp(base + newRoute.path),\r\n                originalPath: base + path,\r\n            };\r\n        }\r\n    }\r\n    changeOptions(options) {\r\n        this.options = options;\r\n    }\r\n    static getParams(search = location.search) {\r\n        return Object.fromEntries(new URLSearchParams(search));\r\n    }\r\n}\r\nfunction registerAnchorEvent(anchor) {\r\n    if (anchor.getAttribute(\"href\")?.startsWith(\"http\"))\r\n        return;\r\n    anchor.addEventListener(\"click\", (e) => {\r\n        e.preventDefault();\r\n        const hasData = anchor.getAttribute(\"data\");\r\n        const hydroProp = replaceBars(hasData);\r\n        const href = anchor.getAttribute(\"href\") || \"\";\r\n        router.go(href, hasData ? hydro[hydroProp] : void 0);\r\n    });\r\n}\r\nfunction registerFormEvent(form) {\r\n    form.addEventListener(\"submit\", (e) => {\r\n        if (!router.options.formHandler)\r\n            return;\r\n        e.preventDefault();\r\n        const action = form.getAttribute(\"action\");\r\n        const method = form.getAttribute(\"method\");\r\n        fetch(action, {\r\n            method,\r\n            ...(![\"HEAD\", \"GET\"].includes(method.toUpperCase())\r\n                ? { body: new FormData(form) }\r\n                : {}),\r\n        })\r\n            .then((res) => router.options.formHandler(res, e))\r\n            .catch(async (err) => {\r\n            if (router.options.errorHandler) {\r\n                await router.options.errorHandler(err, e);\r\n            }\r\n            else {\r\n                console.error(err, e);\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction replaceBars(hydroTerm) {\r\n    if (hydroTerm === null || !hydroTerm.includes(\"{{\"))\r\n        return hydroTerm;\r\n    const [_, hydroPath] = hydroTerm.match(reactivityRegex) || [];\r\n    return hydroPath;\r\n}\r\n// Add EventListener for every added anchor and form Element\r\n$$(\"a\").forEach(registerAnchorEvent);\r\n$$(\"form\").forEach(registerFormEvent);\r\nnew MutationObserver((entries) => {\r\n    for (const entry of entries) {\r\n        for (const node of entry.addedNodes) {\r\n            const nodes = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT, {\r\n                acceptNode(elem) {\r\n                    return [\"form\", \"a\"].includes(elem.localName)\r\n                        ? NodeFilter.FILTER_ACCEPT\r\n                        : NodeFilter.FILTER_REJECT;\r\n                },\r\n            });\r\n            let formOrA;\r\n            while ((formOrA = nodes.nextNode())) {\r\n                if (formOrA.localName === \"a\") {\r\n                    registerAnchorEvent(formOrA);\r\n                }\r\n                else {\r\n                    registerFormEvent(formOrA);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}).observe(document.body, { childList: true, subtree: true });\r\nasync function handleTemplate(route, where) {\r\n    let cacheObj = fetchCache.get(route);\r\n    if (!fetchCache.has(route) || cacheObj?.promise === null) {\r\n        cacheObj.controller?.abort();\r\n        const data = await fetch(route.templateUrl);\r\n        if (!cacheObj) {\r\n            cacheObj = {\r\n                html: await data.text(),\r\n            };\r\n            fetchCache.set(route, cacheObj);\r\n        }\r\n        else {\r\n            cacheObj.html = await data.text();\r\n        }\r\n    }\r\n    Reflect.deleteProperty(cacheObj, \"controller\");\r\n    const copy = where.cloneNode();\r\n    copy.append(html `${(await cacheObj.html) || \"\"}`);\r\n    render(copy, where, false);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}